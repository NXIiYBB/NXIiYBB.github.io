<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Polaroid Frame ðŸ“·</title>
<style>
body{margin:0;font-family:ui-rounded,system-ui,-apple-system,Segoe UI,Roboto,Noto Sans Thai,Noto Sans,sans-serif;background:#f7f7fb;display:flex;flex-direction:column;align-items:center;justify-content:flex-start;padding:16px}
canvas{background:#eee;border-radius:16px;touch-action:none;max-width:100%;height:auto;display:block;margin-bottom:12px}
.controls{display:flex;flex-direction:column;gap:8px;width:100%;max-width:480px}
.controls input[type=text]{padding:8px 12px;border-radius:12px;border:1px solid #ccc;font-size:16px;width:100%}
.controls input[type=file]{font-size:16px}
button{padding:10px 16px;border:none;border-radius:999px;background:#ff91a4;color:#fff;font-size:16px;cursor:pointer;box-shadow:0 4px 8px rgba(0,0,0,0.15)}
button:active{transform:translateY(1px)}
button.secondary{background:#6c5ce7}
</style>
</head>
<body>

<input type="file" id="imgInput" accept="image/*">
<div class="controls">
<input type="text" id="captionInput" placeholder="à¸žà¸´à¸¡à¸žà¹Œà¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸™à¹ˆà¸²à¸£à¸±à¸...">
<div style="display:flex;gap:8px;flex-wrap:wrap">
<button id="fitBtn" class="secondary">Reset / Fit to Frame</button>
<button id="downloadBtn">à¸”à¸²à¸§à¸™à¹Œà¹‚à¸«à¸¥à¸” PNG</button>
</div>
</div>
<canvas id="canvas" width="1080" height="1920"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let img = null;
let imgX = canvas.width/2, imgY = canvas.height/2, imgScale = 1;
let lastX = 0, lastY = 0;
let dragging = false;
let pinchDistance = 0;
let lastScale = 1;

const marginTop = 40, marginSide = 40, marginBottom = 200;
const FRAME_COLOR = '#fff';
const captionInput = document.getElementById('captionInput');

document.getElementById('imgInput').addEventListener('change', e=>{
    const file = e.target.files[0];
    if(file){
        const reader = new FileReader();
        reader.onload = ev=>{
            img = new Image();
            img.onload = ()=>{
                fitImageToFrame();
                draw();
            }
            img.src = ev.target.result;
        }
        reader.readAsDataURL(file);
    }
});

// Fit / Reset function
function fitImageToFrame(){
    if(!img) return;
    imgX = canvas.width/2;
    imgY = (canvas.height-marginBottom)/2 + marginTop;
    imgScale = Math.min((canvas.width-2*marginSide)/img.width,(canvas.height-marginTop-marginBottom)/img.height);
}

// Pointer events à¸ªà¸³à¸«à¸£à¸±à¸šà¸¡à¸·à¸­à¸–à¸·à¸­à¹à¸¥à¸° desktop
let pointers = {};

canvas.addEventListener('pointerdown', e=>{
    pointers[e.pointerId] = {x:e.clientX, y:e.clientY};
    if(Object.keys(pointers).length === 1){
        dragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
    } else if(Object.keys(pointers).length === 2){
        const ids = Object.keys(pointers);
        const p1 = pointers[ids[0]], p2 = pointers[ids[1]];
        pinchDistance = Math.hypot(p2.x-p1.x, p2.y-p1.y);
        lastScale = imgScale;
        dragging = false;
    }
    canvas.setPointerCapture(e.pointerId);
});

canvas.addEventListener('pointermove', e=>{
    if(!img) return;
    if(Object.keys(pointers).length === 1 && dragging){
        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;
        imgX += dx * (canvas.width / canvas.getBoundingClientRect().width);
        imgY += dy * (canvas.height / canvas.getBoundingClientRect().height);
        lastX = e.clientX;
        lastY = e.clientY;
        draw();
    } else if(Object.keys(pointers).length === 2){
        const ids = Object.keys(pointers);
        const p1 = pointers[ids[0]], p2 = pointers[ids[1]];
        const currentDistance = Math.hypot(p2.x-p1.x, p2.y-p1.y);
        const scaleFactor = currentDistance/pinchDistance;
        imgScale = Math.max(0.1, lastScale * scaleFactor);
        draw();
    }
});

canvas.addEventListener('pointerup', e=>{
    delete pointers[e.pointerId];
    if(Object.keys(pointers).length<2) lastScale = imgScale;
    dragging=false;
    canvas.releasePointerCapture(e.pointerId);
});

canvas.addEventListener('pointercancel', e=>{
    delete pointers[e.pointerId];
    dragging=false;
    canvas.releasePointerCapture(e.pointerId);
});

function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // frame
    ctx.fillStyle = FRAME_COLOR;
    ctx.fillRect(0,0,canvas.width,canvas.height-marginBottom);
    // draw image
    if(img){
        const dw = img.width*imgScale;
        const dh = img.height*imgScale;
        const dx = imgX - dw/2;
        const dy = imgY - dh/2;
        ctx.drawImage(img, dx, dy, dw, dh);
    }
    // caption
    ctx.fillStyle = '#ff6f91';
    ctx.font = '36px Comic Sans MS, system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(captionInput.value||'', canvas.width/2, canvas.height - marginBottom/2 - 20);
    // date
    const date = new Date();
    const dateStr = date.toLocaleDateString('th-TH', {day:'numeric', month:'short', year:'numeric'});
    ctx.fillStyle = '#ff91a4';
    ctx.font = '24px Comic Sans MS, system-ui';
    ctx.fillText(dateStr, canvas.width/2, canvas.height - marginBottom/2 + 20);
}

// à¸”à¸²à¸§à¸™à¹Œà¹‚à¸«à¸¥à¸” PNG
document.getElementById('downloadBtn').addEventListener('click', ()=>{
    const link = document.createElement('a');
    link.download = `polaroid-${Date.now()}.png`;
    link.href = canvas.toDataURL('image/png');
    link.click();
});

// live update caption
captionInput.addEventListener('input', draw);

// fit / reset
document.getElementById('fitBtn').addEventListener('click', ()=>{
    fitImageToFrame();
    draw();
});

draw();
</script>
</body>
</html>
